# Lex实验报告

## 学号：   171250649              姓名：  赵文祺

## 截图

### 源文件目录截图

### REJava.l资源文件截图

### 输入文件/流内容截图

### 输出token的截图



## 1.实现词法分析需要的具体步骤

1. 从REJava.I中读取正则表达式
2. 规范化正则表达式
3. 将正则表达式转为后缀的形式
4. 从后缀的正则表达式构造NFA
5. 模拟NFA运行进行字符串匹配
6. 匹配成功返回Token，匹配失败提供报错



## 2.重要的转化步骤的实现

### 2.1 规范化正则表达式

#### 2.1.1 消除 $\{\}$ ，该正则表达式的定义依赖于另一个正则表达式

比如：

```java
number  {digits}(\.{digits})?(e(\+|-)?{digits})?
digit   [0-9]
digits  {digit}+
```

这时我选择递归地将 $\{\}$ 中的内容替换为不含大括号的正则表达式，若出现一个正则表达式中出现自己饮用自己的情况，则抛出栈溢出异常 `throw new StackOverflowError("Recursive definition" + pattern + "can not exist!");。`

#### 2.1.2 消除 `[]` 

将 `[A-Z]` 转为 `(A|b|c......Y|Z)` ，依靠A到Z在ascii码中按顺序排列的性质，只需要遍历添加即可

#### 2.1.3 添加必要的连接符

- 我选择中文的书名号 `《` 作为连接

- 为了在适当的位置添加连接符，我将需要用到的操作符分为两类

所有操作符: `Arrays.asList('|', '?', '+', '*', '^', ')');`

二元操作符: `Collections.singletonList('|')`

- 对正则表达式进行遍历，判断在当前字符之后是否应该添加连接符 `《`

同时对当前字符和下一个字符进行判断，如果当前字符是二元操作符，或者下一个字符是所有操作符，都不应该在当前字符之后添加连接符 `《`

#### 2.1.4 转义字符

在以上的讨论中，如果出现转义字符 `\` ，则需要特殊处理。

- 所有的操作符前有转义字符则将其看成一个普通字符

- 转义字符和其下一个字符之间不应出现连接符 `《`
- 双转义字符 `\\` 来匹配单个反斜杠也被考虑在内



### 2.2 将正则表达式转化为后缀形式

这里我定义了一个新的类Label来对每个字符进行包装，使得每个单字符和转义字符都被包装在一个Label中。使两者能够被统一处理

```java
public class Label {
    char c;
    boolean isEscape;
}
```

借鉴数据结构中将计算式转为后缀形式的思想，定义各个操作符的优先级。优先级越高越先与操作数结合

```java
/** Operators precedence map. */
public static final Map<Character, Integer> precedenceMap = new HashMap<>();
static {
    precedenceMap.put('(', 1);
    precedenceMap.put('|', 2);
    precedenceMap.put('《', 3); // explicit concatenation operator
    precedenceMap.put('?', 4);
    precedenceMap.put('*', 4);
    precedenceMap.put('+', 4);
}
```

使用一个Label的栈

- 如果遇到操作数，我们就直接将其加入 `List<Label>` 中。

- 如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中。

- 如果遇到一个右括号，则将栈元素弹出，将弹出的操作符加入 `List<Label>` 中直到遇到左括号为止。左括号只弹出并不加入 `List<Label>` 。

- 如果遇到任何其他的操作符，从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止。弹出完这些元素后，才将遇到的操作符压入到栈中。有一点需要注意，只有在遇到" ) "的情况下我们才弹出" ( "，其他情况我们都不会弹出" ( "。

- 如果我们读到了输入的末尾，则将栈中所有元素依次弹出。



### 2.3 从后缀的正则表达式构造NFA

NFA的底层是一个带边有向图，我根据[Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne](https://algs4.cs.princeton.edu/)，对其中的带权重的有向图进行改造，每条边上包含一个Label表示这条边的字符，如果是 $\epsilon$ 边则将这个Label设为null。并向外部提供addEdge()的接口

先根据TOMPSON算法定义了构造NFA的三个基本操作

- 连接
- 或
- \* 零次或多次

并在此基础上定义了两个拓展操作

- \+ 一次或多次
- ？零次或一次

基本的思想是，创建一个新的NFA，然后将原本NFA中的有向边拷贝到新的NFA中。最后添加必要的 $\epsilon$ 边。需要注意的是对于节点的编号，在所有的NFA中，都将源节点的编号设置为0，而将终结节点的编号设置为总节点数减一。

使用了一个Map来建立终结节点与模式名称之间的关联，为后续合并成统一的NFA做准备。